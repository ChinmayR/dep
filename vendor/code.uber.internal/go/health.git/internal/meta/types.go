// Code generated by thriftrw v1.2.0
// @generated

package meta

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go.uber.org/thriftrw/wire"
	"math"
	"strconv"
	"strings"
)

type HealthRequest struct {
	Type *RequestType `json:"type,omitempty"`
}

func (v *HealthRequest) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RequestType_Read(w wire.Value) (RequestType, error) {
	var v RequestType
	err := v.FromWire(w)
	return v, err
}

func (v *HealthRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x RequestType
				x, err = _RequestType_Read(field.Value)
				v.Type = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *HealthRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}
	return fmt.Sprintf("HealthRequest{%v}", strings.Join(fields[:i], ", "))
}

func _RequestType_EqualsPtr(lhs, rhs *RequestType) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func (v *HealthRequest) Equals(rhs *HealthRequest) bool {
	if !_RequestType_EqualsPtr(v.Type, rhs.Type) {
		return false
	}
	return true
}

type HealthStatus struct {
	Ok      bool    `json:"ok"`
	Message *string `json:"message,omitempty"`
	State   *State  `json:"state,omitempty"`
}

func (v *HealthStatus) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueBool(v.Ok), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.State != nil {
		w, err = v.State.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _State_Read(w wire.Value) (State, error) {
	var v State
	err := v.FromWire(w)
	return v, err
}

func (v *HealthStatus) FromWire(w wire.Value) error {
	var err error
	okIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				v.Ok, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				okIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x State
				x, err = _State_Read(field.Value)
				v.State = &x
				if err != nil {
					return err
				}
			}
		}
	}
	if !okIsSet {
		return errors.New("field Ok of HealthStatus is required")
	}
	return nil
}

func (v *HealthStatus) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Ok: %v", v.Ok)
	i++
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.State != nil {
		fields[i] = fmt.Sprintf("State: %v", *(v.State))
		i++
	}
	return fmt.Sprintf("HealthStatus{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _State_EqualsPtr(lhs, rhs *State) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func (v *HealthStatus) Equals(rhs *HealthStatus) bool {
	if !(v.Ok == rhs.Ok) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_State_EqualsPtr(v.State, rhs.State) {
		return false
	}
	return true
}

type RequestType int32

const (
	RequestTypeLegacy  RequestType = 0
	RequestTypeTraffic RequestType = 1
)

func (v RequestType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *RequestType) FromWire(w wire.Value) error {
	*v = (RequestType)(w.GetI32())
	return nil
}

func (v RequestType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "LEGACY"
	case 1:
		return "TRAFFIC"
	}
	return fmt.Sprintf("RequestType(%d)", w)
}

func (v RequestType) Equals(rhs RequestType) bool {
	return v == rhs
}

func (v RequestType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"LEGACY\""), nil
	case 1:
		return ([]byte)("\"TRAFFIC\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

func (v *RequestType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}
	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "RequestType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "RequestType")
		}
		*v = (RequestType)(x)
		return nil
	case string:
		switch w {
		case "LEGACY":
			*v = RequestTypeLegacy
			return nil
		case "TRAFFIC":
			*v = RequestTypeTraffic
			return nil
		default:
			return fmt.Errorf("unknown enum value %q for %q", w, "RequestType")
		}
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "RequestType")
	}
}

type State int32

const (
	StateRefusing  State = 0
	StateAccepting State = 1
	StateStopping  State = 2
	StateStopped   State = 3
)

func (v State) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *State) FromWire(w wire.Value) error {
	*v = (State)(w.GetI32())
	return nil
}

func (v State) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "REFUSING"
	case 1:
		return "ACCEPTING"
	case 2:
		return "STOPPING"
	case 3:
		return "STOPPED"
	}
	return fmt.Sprintf("State(%d)", w)
}

func (v State) Equals(rhs State) bool {
	return v == rhs
}

func (v State) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"REFUSING\""), nil
	case 1:
		return ([]byte)("\"ACCEPTING\""), nil
	case 2:
		return ([]byte)("\"STOPPING\""), nil
	case 3:
		return ([]byte)("\"STOPPED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

func (v *State) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}
	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "State")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "State")
		}
		*v = (State)(x)
		return nil
	case string:
		switch w {
		case "REFUSING":
			*v = StateRefusing
			return nil
		case "ACCEPTING":
			*v = StateAccepting
			return nil
		case "STOPPING":
			*v = StateStopping
			return nil
		case "STOPPED":
			*v = StateStopped
			return nil
		default:
			return fmt.Errorf("unknown enum value %q for %q", w, "State")
		}
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "State")
	}
}
