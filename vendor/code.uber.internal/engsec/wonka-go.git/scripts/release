#!/bin/bash

#
# See README.md for release process and instructions.
#

CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
REQUIRED_BRANCH=master
PROJECT_DIR="$(git rev-parse --show-toplevel)"
VERSION_FILE="$PROJECT_DIR/version.go"
CHANGELOG_FILE="$PROJECT_DIR/CHANGELOG.md"
cd "$PROJECT_DIR"

set -o errexit
set -o nounset
set -o pipefail

check_branch() {
    echo "You are on branch $CURRENT_BRANCH"
    if [ $CURRENT_BRANCH != $REQUIRED_BRANCH ]; then
        echo "You need to on be on $REQUIRED_BRANCH to run this."
        echo
        return 1
    fi
}

require_clean_work_tree () {
    local command="release"

    # Update the index
    git update-index -q --ignore-submodules --refresh
    local err=0

    # Disallow unstaged changes in the working tree
    if ! git diff-files --quiet --ignore-submodules --
    then
        echo "cannot $command: you have unstaged changes."
        git diff-files --name-status -r --ignore-submodules --
        err=1
    fi

    # Disallow uncommitted changes in the index
    if ! git diff-index --cached --quiet HEAD --ignore-submodules --
    then
        echo "cannot $command: your index contains uncommitted changes."
        git diff-index --cached --name-status -r --ignore-submodules HEAD --
        err=1
    fi

    if [ $err = 1 ]; then
        echo "Please commit or stash them."
        return 1
    fi

    echo "Your work tree is clean."
}

update_version() {
    local version="$1"
    perl -p -i -e 'BEGIN { $v = shift } m/const Version/ && s/"([^"]+)"/"$v"/;' "$version" "$VERSION_FILE"
}

current_version() {
    perl -n -e 'm/const Version/ && m/"([^"]+)"/ && print $1;' "$VERSION_FILE"
}

increment_major() {
    local version="$1"
    # Discards any labels.
    perl -e 'my ($major, $minor, $patch) = split(/\./, $ARGV[0]); print join(q{.}, ++$major, 0, 0);' "$version"
}

increment_minor() {
    local version="$1"
    # Discards any labels.
    perl -e 'my ($major, $minor, $patch) = split(/\./, $ARGV[0]); print join(q{.}, $major, ++$minor, 0);' "$version"
}

increment_patch() {
    local version="$1"
    # Discards any labels.
    perl -e 'my ($major, $minor, $patch) = split(/\./, $ARGV[0]); print join(q{.}, $major, $minor, ++$patch);' "$version"
}

remove_label() {
    local version="$1"
    perl -e 'my $v = $ARGV[0]; $v =~ s/[^\d.].*$//; print $v;' "$version"
}

back_to_dev() {
    local version="$1"
    echo "$(increment_patch "$version")-dev"
}

confirm() {
    local prompt="$1"

    read -p "$prompt [yN] " answer
    case "$answer" in
        [yY]* )
            return 0
            ;;
        * )
            echo "Cancelling release."
            return 1
    esac
}

validate_changelog() {
    local editor=${EDITOR:-vim}
    # TODO: confirm version is first heading.
    # TODO: set the date automatically.
    while grep --max-count 1 --quiet '^## v.*(unreleased)' "$CHANGELOG_FILE"; do
        echo "Changelog still says 'unreleased'. Enter y to edit the file. Anything else to exit."
        if confirm "Open $EDITOR to modify $CHANGELOG_FILE?"; then
            $EDITOR -- "$CHANGELOG_FILE"
            echo
        else
            return 1
        fi
    done
    return 0
}

# Add a new heading with the given version and "unreleased" to the changelog.
set_changelog_unreleased() {
    local version="$1"
    perl -p -i -e 'BEGIN { $v = shift; $done = 0; } if (!$done && m/^## v/) { print "## v$v (unreleased)\n\n\n"; $done = 1; }' \
        "$version" "$CHANGELOG_FILE"
}

require_clean_work_tree
check_branch

git fetch --tags # Make sure we know about any existing releases
readonly CURRENT_VERSION=$(current_version)

# We expect release manager to edit version.go by hand and then run `make release`
readonly RELEASE_VERSION=$(remove_label "$CURRENT_VERSION")
readonly RELEASE_TAG="v$RELEASE_VERSION"
if sha=$(git rev-parse --quiet --verify "$RELEASE_TAG"); then
    echo "Tag $RELEASE_TAG already exists and points to $sha."
    echo "Choose a new version and edit $VERSION_FILE."
    exit 1
fi

confirm "Tag and release version '$RELEASE_VERSION'?"

# Release manager may have forgotten to remove the -dev label.
update_version "$RELEASE_VERSION"
validate_changelog

git commit --message "Tagging release $RELEASE_VERSION" "$VERSION_FILE" "$CHANGELOG_FILE"
git tag --annotate --message "$RELEASE_TAG" "$RELEASE_TAG"

# Change version again so future builds will not identity themselves
# incorrectly as RELEASE_VERSION.
readonly DEV_VERSION=$(back_to_dev "$RELEASE_VERSION")
update_version "$DEV_VERSION"
set_changelog_unreleased "$DEV_VERSION"
git commit --message "Back to development" "$VERSION_FILE" "$CHANGELOG_FILE"

git push --tags origin master
