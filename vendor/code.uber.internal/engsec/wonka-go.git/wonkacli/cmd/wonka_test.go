// Code generated by mockery v1.0.0
package cmd

import (
	context "context"
	time "time"

	wonka "code.uber.internal/engsec/wonka-go.git"
	mock "github.com/stretchr/testify/mock"
)

// MockWonka is an autogenerated mock type for the Wonka type
type MockWonka struct {
	mock.Mock
}

// Admin provides a mock function with given fields: ctx, request
func (_m *MockWonka) Admin(ctx context.Context, request wonka.AdminRequest) error {
	ret := _m.Called(ctx, request)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, wonka.AdminRequest) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CertificateSignRequest provides a mock function with given fields: ctx, cert, req
func (_m *MockWonka) CertificateSignRequest(ctx context.Context, cert *wonka.Certificate, req *wonka.CertificateSignature) error {
	ret := _m.Called(ctx, cert, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *wonka.Certificate, *wonka.CertificateSignature) error); ok {
		r0 = rf(ctx, cert, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClaimImpersonateTTL provides a mock function with given fields: ctx, impersonatedEntity, entityName, ttl
func (_m *MockWonka) ClaimImpersonateTTL(ctx context.Context, impersonatedEntity string, entityName string, ttl time.Duration) (*wonka.Claim, error) {
	ret := _m.Called(ctx, impersonatedEntity, entityName, ttl)

	var r0 *wonka.Claim
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *wonka.Claim); ok {
		r0 = rf(ctx, impersonatedEntity, entityName, ttl)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Claim)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, time.Duration) error); ok {
		r1 = rf(ctx, impersonatedEntity, entityName, ttl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClaimRequest provides a mock function with given fields: ctx, claim, dest
func (_m *MockWonka) ClaimRequest(ctx context.Context, claim string, dest string) (*wonka.Claim, error) {
	ret := _m.Called(ctx, claim, dest)

	var r0 *wonka.Claim
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *wonka.Claim); ok {
		r0 = rf(ctx, claim, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Claim)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, claim, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClaimRequestTTL provides a mock function with given fields: ctx, claim, dest, ttl
func (_m *MockWonka) ClaimRequestTTL(ctx context.Context, claim string, dest string, ttl time.Duration) (*wonka.Claim, error) {
	ret := _m.Called(ctx, claim, dest, ttl)

	var r0 *wonka.Claim
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *wonka.Claim); ok {
		r0 = rf(ctx, claim, dest, ttl)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Claim)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, time.Duration) error); ok {
		r1 = rf(ctx, claim, dest, ttl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClaimResolve provides a mock function with given fields: ctx, entityName
func (_m *MockWonka) ClaimResolve(ctx context.Context, entityName string) (*wonka.Claim, error) {
	ret := _m.Called(ctx, entityName)

	var r0 *wonka.Claim
	if rf, ok := ret.Get(0).(func(context.Context, string) *wonka.Claim); ok {
		r0 = rf(ctx, entityName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Claim)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, entityName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClaimResolveTTL provides a mock function with given fields: ctx, entityName, ttl
func (_m *MockWonka) ClaimResolveTTL(ctx context.Context, entityName string, ttl time.Duration) (*wonka.Claim, error) {
	ret := _m.Called(ctx, entityName, ttl)

	var r0 *wonka.Claim
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *wonka.Claim); ok {
		r0 = rf(ctx, entityName, ttl)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Claim)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, time.Duration) error); ok {
		r1 = rf(ctx, entityName, ttl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Decrypt provides a mock function with given fields: ctx, cipherText, entity
func (_m *MockWonka) Decrypt(ctx context.Context, cipherText []byte, entity string) ([]byte, error) {
	ret := _m.Called(ctx, cipherText, entity)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, []byte, string) []byte); ok {
		r0 = rf(ctx, cipherText, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, string) error); ok {
		r1 = rf(ctx, cipherText, entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Encrypt provides a mock function with given fields: ctx, plainText, entity
func (_m *MockWonka) Encrypt(ctx context.Context, plainText []byte, entity string) ([]byte, error) {
	ret := _m.Called(ctx, plainText, entity)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, []byte, string) []byte); ok {
		r0 = rf(ctx, plainText, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, string) error); ok {
		r1 = rf(ctx, plainText, entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Enroll provides a mock function with given fields: ctx, location, claims
func (_m *MockWonka) Enroll(ctx context.Context, location string, claims []string) (*wonka.Entity, error) {
	ret := _m.Called(ctx, location, claims)

	var r0 *wonka.Entity
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) *wonka.Entity); ok {
		r0 = rf(ctx, location, claims)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Entity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, location, claims)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnrollEntity provides a mock function with given fields: ctx, entity
func (_m *MockWonka) EnrollEntity(ctx context.Context, entity *wonka.Entity) (*wonka.Entity, error) {
	ret := _m.Called(ctx, entity)

	var r0 *wonka.Entity
	if rf, ok := ret.Get(0).(func(context.Context, *wonka.Entity) *wonka.Entity); ok {
		r0 = rf(ctx, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Entity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *wonka.Entity) error); ok {
		r1 = rf(ctx, entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EntityName provides a mock function with given fields:
func (_m *MockWonka) EntityName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// LastError provides a mock function with given fields:
func (_m *MockWonka) LastError() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Lookup provides a mock function with given fields: ctx, entityName
func (_m *MockWonka) Lookup(ctx context.Context, entityName string) (*wonka.Entity, error) {
	ret := _m.Called(ctx, entityName)

	var r0 *wonka.Entity
	if rf, ok := ret.Get(0).(func(context.Context, string) *wonka.Entity); ok {
		r0 = rf(ctx, entityName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*wonka.Entity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, entityName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Ping provides a mock function with given fields: ctx
func (_m *MockWonka) Ping(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Sign provides a mock function with given fields: data
func (_m *MockWonka) Sign(data []byte) ([]byte, error) {
	ret := _m.Called(data)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Verify provides a mock function with given fields: ctx, data, sig, entity
func (_m *MockWonka) Verify(ctx context.Context, data []byte, sig []byte, entity string) bool {
	ret := _m.Called(ctx, data, sig, entity)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte, string) bool); ok {
		r0 = rf(ctx, data, sig, entity)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}
